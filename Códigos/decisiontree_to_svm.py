# -*- coding: utf-8 -*-
"""decisionTree to SVM.ipynb

Automatically generated by Colaboratory.

**Primeiro passo**: 

*   incluir as bibliotecas (classes) necessárias para criar o modelo
"""

# make some small toy datasets available to the programa
from sklearn import datasets as ds 
# import Decision Tree Estimator
from sklearn.tree import DecisionTreeClassifier as dt
# import a library to split the original dataset into random test and train subsets
from sklearn.model_selection import train_test_split
# libraries to evaluate the model
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score
# numerical package for Python
import numpy as np
### to create the tree
from sklearn.externals.six import StringIO  
from IPython.display import Image  
from sklearn.tree import export_graphviz
import pydotplus

"""**Segundo passo**: 
* Carregar o conjunto de dados
* Préprocessar (se necessário): limpar, criar/remover atributos
* Dividir em treino e teste
"""

iris=ds.load_iris()
# show iris documentation
#print(iris.DESCR)
# selects only the attributs of the dataset
print(iris)
X=iris.data
print(X)
# now, the classes
y=iris.target
print(y)
# Remark: y[0] stores the class of X[0], and so on.
# time to split the dataset (70% for training and 30% for testing)
X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=.3, random_state=9)
# count how many examples are splitted for each class
print('Training:',iris.target_names[0],np.count_nonzero(y_train==0))
print('Training:',iris.target_names[1],np.count_nonzero(y_train==1))
print('Training:',iris.target_names[2],np.count_nonzero(y_train==2))
print('Testing:',iris.target_names[0],np.count_nonzero(y_test==0))
print('Testing:',iris.target_names[1],np.count_nonzero(y_test==1))
print('Testing:',iris.target_names[2],np.count_nonzero(y_test==2))

"""**Terceiro Passo**:
* Construir o modelo de classificação
* Avaliar o modelo
"""

# myTree is an object of DecistionTreeClassifier
myTree=dt()
# print the default hyperparameters
# build the model: remember X_train and y_train are the train datasets (data and labels)
myTree.fit(X_train,y_train) 
# let's check our model using our testing set
# now we have compare the real classes y_test and the predicted ones y_hat
##
# dot_data = StringIO()
# export_graphviz(myTree, out_file=dot_data,  
#                 filled=True, rounded=True,
#                 special_characters=True)
# graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
# Image(graph.create_png())

"""# SVM"""

from sklearn.svm import SVC
from sklearn.svm import NuSVC
from sklearn.svm import LinearSVC

# create model
mySVC = SVC(C=90)

# train
mySVC.fit(X_train, y_train)

"""## SVM vs. Decision Tree"""

print('DECISION TREE')

preds = myTree.predict(X_test)

acc = accuracy_score(y_test, preds)
print('Accuracy:',acc,'that is, %.2f'%(acc*100),'%')

# a detailed report about our model performance
dmetric = classification_report(y_test, preds)
print('Evaluation report\n',dmetric)

print('SVC')

preds = mySVC.predict(X_test)

acc = accuracy_score(y_test, preds)
print('Accuracy:',acc,'that is, %.2f'%(acc*100),'%')

# a detailed report about our model performance
dmetric = classification_report(y_test,preds)
print('Evaluation report\n',dmetric)

"""## Plotting graphics for different options

First set-up the plotting tool
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm, datasets


def make_meshgrid(x, y, h=.02):
    """Create a mesh of points to plot in

    Parameters
    ----------
    x: data to base x-axis meshgrid on
    y: data to base y-axis meshgrid on
    h: stepsize for meshgrid, optional

    Returns
    -------
    xx, yy : ndarray
    """
    x_min, x_max = x.min() - 1, x.max() + 1
    y_min, y_max = y.min() - 1, y.max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
    return xx, yy


def plot_contours(ax, clf, xx, yy, **params):
    """Plot the decision boundaries for a mySVC.

    Parameters
    ----------
    ax: matplotlib axes object
    clf: a classifier
    xx: meshgrid ndarray
    yy: meshgrid ndarray
    params: dictionary of params to pass to contourf, optional
    """
    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    
    
    Z = Z.reshape(xx.shape)
    
    out = ax.contourf(xx, yy, Z, **params)
    return out
    # return acc


# Take the first two features. We could avoid this by using a two-dim dataset
X = X_test[:, :2]
y = y_test

"""Then, add the plotting data"""

# MODELS
model_set = [
    [
        SVC(),
        SVC(kernel='linear'),
    ],
    
    [
        SVC(C=90),
        SVC(C=0.1),
    ],
    
    [
        SVC(kernel='poly', degree=5),
        SVC(kernel='poly', degree=5, coef0=7),
    ],
    
    [
        NuSVC(),
        LinearSVC(),
    ],
]

# TITLES
title_set = [
    [
        'Standard SVC',
        'SVC with (kernel=linear)',
    ],
    
    [
        'SVC with (C=90)',
        'SVC with (C=0.1)',
    ],
    
    [
        'SVC with(kernel=poly, degree=5)',
        'SVC with(kernel=poly, degree=5, coef0=7)',
    ],
    
    [
        'Standard NuSVC',
        'Standard LinearSVC',
    ], 
    
]

# train models
for models in model_set:
    for model in models:
        model.fit(X_train[:, :2], y_train)

"""Finally, plot results"""

X0, X1 = X[:, 0], X[:, 1]
xx, yy = make_meshgrid(X0, X1)

for models, titles in zip(model_set, title_set):
    
    fig, sub = plt.subplots(1, 2, figsize=(15, 5))
    plt.subplots_adjust(wspace=0.4, hspace=0.4)
    
    for clf, title, ax in zip(models, titles, sub.flatten()):

        plot_contours(ax, clf, xx, yy,
                      cmap=plt.cm.coolwarm, alpha=0.8)
        #acc = accuracy_score(y_test, preds)

        ax.scatter(X0, X1, c=y, cmap=plt.cm.coolwarm, s=20, edgecolors='k')
        ax.set_xlim(xx.min(), xx.max())
        ax.set_ylim(yy.min(), yy.max())
        ax.set_xlabel('Sepal length')
        ax.set_ylabel('Sepal width')
        ax.set_xticks(())
        ax.set_yticks(())
        #print(acc)
        #ax.set_title(title + ' - ' + acc)
        ax.set_title(title)

plt.show()
